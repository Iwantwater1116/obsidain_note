#程式語言教學與技術文件 #Google派系 #Golang #Golang基本學識
# 正規表示法

可以參考正規表示法的教學頁：

[正規表示法表格](https://www.notion.so/99e258327c8f47aabd0733a1dfd58f1e?pvs=21)

接下來就用程式碼來簡單說明Golang的正規表示法呈現：

```go
func RegexPractice() {
	match, _ := regexp.MatchString("p([a-z]+)ch", "peach"))
//有符合正規表達式的字串就給true
	fmt.Println(match)

	r, _ := regexp.Compile("p([a-z]+)ch")//編譯規則，讓之後使用都不用再寫表達式編譯一次
	p := fmt.Println

	p(r.MatchString("peach"))
//有符合正規表達式的字串就給true
	p(r.FindString("peach punch"))
//會回傳第一個符合表達式的字串，就是peach
	p(r.FindStringIndex("peach punch"))
//或回傳符合表達式的字串區間，像peach就是[0 5]
	p(r.FindStringSubmatch("peach punch"))
//回傳子表達式的符合項目，[a-z]這部分就是子項目，配合父項目所以會回peach ea
	p(r.FindStringSubmatchIndex("peach punch"))
//回傳子表達式的符合項目區間，[a-z]這部分就是子項目，配合父項目所以會回[0 5 1 3]
	p(r.FindAllString("peach punch pinch", -1))
//回傳所有符合表達式的字串，所以回傳[peach punch pinch]
	p(r.FindAllStringSubmatchIndex("peach punch pinch", -1))
//回傳所有符合表達式的字串區間，所以回傳[[0 5 1 3] [6 11 7 9] [12 17 13 15]]
	p(r.FindAllString("peach punch pinch", 2))
//回傳所有府和表達式的前兩個字串，也就是[peach punch]
	p(r.Match([]byte("peach")))//也可以用byte作比對喔

	r = regexp.MustCompile("p([a-z]+)ch")
//MustComoile和Compile的功能相同，但一個是給error訊息，Must則是會給出panic
	p(r)

	p(r.ReplaceAllString("a peach", "<fruit>"))
//ReplaceAllString會把符合的字串替換成設定的字串，peach符合，所以會變成 a <fruit>

	in := []byte("a peach")
	out := r.ReplaceAllFunc(in, bytes.ToUpper)
//把符合的字串替換處理掉，不過這邊是用byte
	p(string(out))
}
```

Output：

```bash
true
true
peach
[0 5]
[peach ea]
[0 5 1 3]
[peach punch pinch]
[[0 5 1 3] [6 11 7 9] [12 17 13 15]]
[peach punch]
true
p([a-z]+)ch
a <fruit>
a PEACH
```