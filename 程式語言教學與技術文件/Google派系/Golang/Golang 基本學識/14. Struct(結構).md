#程式語言教學與技術文件 #Google派系 #Golang #Golang基本學識
# Struct(結構)

與C語言一樣的定義，跟物件導向的Class有點像，但他並無法做繼承的動作，所以不能算是物件導向大概就長這樣而已

```go
type person struct {
	name string
	age  int
}

func StructPractice() {
	fmt.Println(person{"Bob", 20})
	fmt.Println(person{name: "Alice", age: 30})
	fmt.Println(person{name: "Fred"})

	fmt.Println(&person{name: "Ann", age: 40})
	s := person{name: "Sean", age: 50}
	fmt.Println(s.name)

	sp := &s
	fmt.Println(sp.age)

	sp.age = 51
	fmt.Println(sp.age)
}
```

# 同場加映：Struct跟Class有什麼不同?

# **結構（Struct）**

1. 是一種實質型別（Value Type）。
2. 存放在記憶體的Stack區。
3. 不需要使用new就可以產生一份新的Struct。
4. 若裡面有N個欄位，那麼一定要把N個欄位填滿，這個Struct才可以開始被使用。
5. 不能擁有空參數的建構子（Constructor），若一定要寫建構子，則在建構子內要把所有欄位都指派值進去。
6. 欄位不可以使用初始化賦值，請走建構子一途。

# **類別（Class）**

1. 是一種參考型別（Reference Type）。
2. 存放在記憶體的Heap區。
3. 一定要使用new來產生一份新的Instance。
4. 若裡面有N個欄位，那麼不需要把N個欄位填滿，這個Instance才可以開始被使用。
5. 能購擁有空參數的建構子（Constructor）。
6. 欄位可以使用初始化賦值，例如：public string cName = "尚未命名";。

# **結構（Struct）與類別（Class）最大的差別**

簡單的說，就是「效能」。使用「Stack」來存放的結構（Struct），在進行耗用大量記憶體來存放「資料」時，基本上完全不會產生記憶體碎片化的問題，且在Struct離開Function時，這些記憶體會馬上被Release出去，讓系統的記憶體佔用率極低。反觀使用「Heap」來存放的類別（Class），，在進行耗用大量記憶體來存放「資料」時，在那邊參考來參考去，不僅造成碎片化，且當程式設計師忘記把Reference釋出（Dispose、Null），這些被佔用的記憶體甚至等到整個程式的生命週期結束後都不見得會被釋放掉（Release），必須仰賴垃圾蒐集（GC, Garbage Collection）來幫我們回收。